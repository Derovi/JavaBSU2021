# Домашняя работа №2

Вам нужно оформить решение своей первой домашки как библиотеку и использовать ее, чтобы написать front-end для приложения. В build.gradle библиотеки нужно сделать задачу publish, которая будет вызываться при push в master при изменениях в этой библиотеки. Эта задача должна заливать библиотеку на github packages, а в репозитории фронта вы должны подключить эту библиотеку.

## Добавляем gradle
Переименуйте директорию с вашей первой домашней работой `.../lab-01-quizer --> .../lab-01-quizer-lib`, добавьте туда gradle. Оформите код ввиде библиотеки, т.e. функция `public static void main()` там не нужна.

Предварительно почитайте про основы gradle, чтобы вы смогли для себя ответить на базовые вопросы - 
* Для чего нужны блоки `plugins`, `repositories`, `dependencies`, `test`?
* Чем отличается `api`, `compile` и `implementation` в блоке `dependencies`?

## А что мы сделали?

Вообще, gradle-конфигурация пишется на языке `groovy`. Gradle имеет динамическую компиляцию в Java-байдкод, напрямую работает с другим Java-кодом, большинство кода на Java является корректным на groovy, однако groovy имеет гораздо больше синтаксических возможностей.

На самом деле вся конфигурация - некоторый код, который выполняется в контексте некоторого объекта Project.  `plugins`, `repositories`, `dependencies`, `test` - функции у Project, которые принимают лямбду - Closure. Эта лямбда уже имеет другой контекст. Например, код, который вы пишите в блоке `dependencies` на самом деле исполняется на объекте `project.dependencies`, который имеет тип `DependenciesHandler`.

Важно понимать, что это все не какие-то ужасные костыли, а просто обычный код на groovy, а gradle можно воспринимать как фреймворк.

Когда вы пишите 
```groovy
dependencies {
    api 'com.fasterxml.jackson.core:jackson-databind:2.12.5'
    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.12.5'
}
```

На самом деле вы вызываете функцию dependencies, в которую передаете лямбду, api и implementation - тоже функции, можно было бы написать так:

```groovy
this.dependencies({
    delegate.api('com.fasterxml.jackson.core:jackson-databind:2.12.5')
    delegate.implementation('com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.12.5')
})
```

На паре я показывал такой код
```groovy
5.times { index ->
    task("task$index") {
        group("custom")

        if (index > 0) dependsOn("task${index - 1}")

        doLast {
            println "Hello i am task$it"
        }
    }
}
```

Попробуйте вспомнить/ разобраться как получились такие конструкции и попробовать написать его чуть более похожим на Java.

Надеюсь, я принес немного понимания почему gradle такой мощный, гибкий, откуда беруться все эти блоки и почему это не костыли.

Советую почитать что такое задачи в gradle и попробовать сделать свою. Например, которая будет собирать проект, а полученный jar-файл подписывать номером версии и копировать в какую-нибудь директорию.

## Github packages
Создайте задачу publish в build.gradle, которая будет паблишить вашу библиотеку в github packages. Потестируйте с разными версиями внутри build.gradle.

## Github actions
Настройте Github Actions так, чтобы при push в master вашего репозитория вызывалась задача publish, если были изменения в файлах (или файле build.gradle).

## Используем библиотеку
Создайте директорию `.../lab-02-quizer-app/quizer-cli` [cli - command line interface], и реализуйте там консольное приложение. По сути, там должен быть просто Main из вашей первой домашки, который не попал в quiz-library. Quiz-library подключите в dependencies через gradle так, чтобы получать его с github packages.

## Приложение на Swing
Создайте директорию `.../lab-02-quizer-app/quizer-swing`, и реализуйте там оконное приложение. После запуска показывается список доступных тестов, пользователю нужно ввести название теста, в конце теста отображается оценка и статистика.

## Обновление
Придумайте какое-нибудь обновление для библиотеки, измените ее версию, запуште, используйте нововведение в приложении на swing, а в консольном оставьте старую версию.
