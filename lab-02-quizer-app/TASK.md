# Домашняя работа №2

Вам нужно оформить решение своей первой домашки как библиотеку и использовать ее, чтобы написать front-end для приложения. В build.gradle библиотеки нужно сделать задачу publish, которая будет вызываться при push в master при изменениях в этой библиотеки. Эта задача должна заливать библиотеку на github packages, а в репозитории фронта вы должны подключить эту библиотеку.

## Добавляем gradle
Предварительно почитайте про основы gradle, чтобы вы смогли для себя ответить на базовые вопросы - 
* Для чего нужны блоки `plugins`, `repositories`, `dependencies`, `test`?
* Чем отличается `api`, `compile` и `implementation` в блоке `dependencies`?

Для начала:
* Смерджите pull request первой домашки в master. 
* Затем нужно синхронизоваться с основным репозиторием (можно нажать кнопку **fetch upstream** на github в корне своего репозитория). 
* Если возникнут конфликты, необходимо их решить. Директория `lab-01-quizer` должна переименоваться в `lab-02-quizer-lib`.
* Создайте ветку `quizer-app`, в которой будете делать вторую домашку.
* Убедитесь, что директория `.../lab-01-quizer` стала называться `.../lab-01-quizer-lib`. Если у вас осталась пустая директория `.../lab-01-quizer`, удалите.

Теперь код первой домашки будет не самостоятельным приложением, а библиотекой, которую можно использовать для создания приложений с опросами.

* Уберите `public static void main()` из библиотеки (`.../lab-01-quizer-lib`). Это - библиотека, она не должна запускаться.

Создайте файл конфигурации build.gradle. Если вы предварительно почитали про основы gradle, проблем у вас не возникнет.
* Обратите внимание, что в секции `plugins` вместо `java` следует указать `java-library` (почитайте про различия).

Скорее всего, вы собирали/ запускали проект с помощью средств intellij idea. Сейчас вам нужно настроить там проект gradle. Проще всего это делать следующим образом:
* Добавьте файл конфигурации build.gradle в проект.
* Удалите ".idea" и "*.iml".
* В Intellij Idea импортируйте проект, выбрав "Import Project..."



## А что мы сделали?

Вообще, gradle-конфигурация пишется на языке `groovy`. Gradle имеет динамическую компиляцию в Java-байдкод, напрямую работает с другим Java-кодом, большинство кода на Java является корректным на groovy, однако groovy имеет гораздо больше синтаксических возможностей.

На самом деле вся конфигурация - некоторый код, который выполняется в контексте некоторого объекта Project.  `plugins`, `repositories`, `dependencies`, `test` - функции у Project, которые принимают лямбду - Closure. Эта лямбда уже имеет другой контекст. Например, код, который вы пишите в блоке `dependencies` на самом деле исполняется на объекте `project.dependencies`, который имеет тип `DependenciesHandler`.

Важно понимать, что это все не какие-то ужасные костыли, а просто обычный код на groovy, а gradle можно воспринимать как фреймворк.

Когда вы пишите 
```groovy
dependencies {
    api 'com.fasterxml.jackson.core:jackson-databind:2.12.5'
    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.12.5'
}
```

На самом деле вы вызываете функцию dependencies, в которую передаете лямбду, api и implementation - тоже функции, можно было бы написать так:

```groovy
this.dependencies({
    delegate.api('com.fasterxml.jackson.core:jackson-databind:2.12.5')
    delegate.implementation('com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.12.5')
})
```

На паре я показывал такой код
```groovy
5.times { index ->
    task("task$index") {
        group("custom")

        if (index > 0) dependsOn("task${index - 1}")

        doLast {
            println "Hello i am task$it"
        }
    }
}
```

Попробуйте вспомнить/ разобраться как получились такие конструкции и попробовать написать его чуть более похожим на Java.

Надеюсь, я принес немного понимания почему gradle такой мощный, гибкий, откуда беруться все эти блоки и почему это не костыли.

Советую почитать что такое задачи в gradle и попробовать сделать свою. Например, которая будет собирать проект, а полученный jar-файл подписывать номером версии и копировать в какую-нибудь директорию.

## Github packages
Создайте задачу publish в build.gradle, которая будет паблишить вашу библиотеку в github packages. Потестируйте с разными версиями внутри build.gradle.

**[Не получилось](https://letmegooglethat.com/?q=publishing+to+github+packages+with+gradle)**

**[Все еще](https://github.com/Derovi/dismess/blob/master/build.gradle#L36)**

**[Да](https://t.me/derovi)**

## Github actions
Настройте Github Actions так, чтобы при push в master вашего репозитория вызывалась задача publish, если были изменения в файлах (или файле build.gradle).

**Я специально не пишу подробнее, потому что разобраться - важная часть задания, но если возникнут проблемы, сообщите.**

## Используем библиотеку
Создайте директорию `.../lab-02-quizer-app/quizer-cli` [cli - command line interface], и реализуйте там консольное приложение. По сути, там должен быть просто Main из вашей первой домашки, который не попал в quiz-library. Quiz-library подключите в dependencies через gradle так, чтобы получать его с github packages. Другими словами, функцианально тут должно получиться то, что у вас было в первой домашке.

## Приложение на Swing
Создайте директорию `.../lab-02-quizer-app/quizer-swing`, и реализуйте там оконное приложение. После запуска показывается список доступных тестов, пользователю нужно ввести название теста, в конце теста отображается оценка и статистика.

## Обновление
Придумайте какое-нибудь обновление для библиотеки, измените ее версию, запуште, используйте нововведение в приложении на swing, а в консольном оставьте старую версию.
